<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<meta name="description" content="A memorial page honoring Aaron Anthony Ebanks - move your cursor or touch to reveal cherished memories" />
<title>In Memory Of Aaron Anthony Ebanks</title>
<link rel="icon" type="image/png" href="icons8-bmw-100.png">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600&display=swap" rel="stylesheet">
<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #000;
}

body {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
text-align: center;
box-sizing: border-box;
position: relative;
}

h1 {
font-family: â€˜Playfair Displayâ€™, serif;
font-weight: 600;
line-height: 1.3;
font-size: clamp(1.8rem, 6vw, 4.5rem);
color: #ff69b4;
text-shadow:
1.5px 0 0 #000,
-1.5px 0 0 #000,
0 1.5px 0 #000,
0 -1.5px 0 #000,
0 6px 18px rgba(255,105,180,0.5);
animation: heartbeat 2s infinite;
z-index: 2;
position: relative;
margin: 0;
padding: 20px;
}

@keyframes heartbeat {
0%,100% {
text-shadow: 1.5px 0 0 #000, -1.5px 0 0 #000, 0 1.5px 0 #000, 0 -1.5px 0 #000, 0 6px 18px rgba(255,105,180,0.5);
transform: scale(1);
}
25% {
text-shadow: 2px 0 0 #000, -2px 0 0 #000, 0 2px 0 #000, 0 -2px 0 #000, 0 10px 30px rgba(255,105,180,0.9);
transform: scale(1.02);
}
50% {
text-shadow: 1.5px 0 0 #000, -1.5px 0 0 #000, 0 1.5px 0 #000, 0 -1.5px 0 #000, 0 6px 18px rgba(255,105,180,0.5);
transform: scale(1);
}
75% {
text-shadow: 2.5px 0 0 #000, -2.5px 0 0 #000, 0 2.5px 0 #000, 0 -2.5px 0 #000, 0 12px 36px rgba(255,105,180,1);
transform: scale(1.03);
}
}

.glow {
position: fixed;
width: 200px;
height: 200px;
background: radial-gradient(circle, rgba(255,105,180,0.8) 0%, rgba(255,105,180,0) 70%);
border-radius: 50%;
pointer-events: none;
transform: translate(-50%, -50%);
z-index: 3;
transition: opacity 0.15s ease;
opacity: 0;
}

#revealCanvas {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
z-index: 1;
pointer-events: none;
}

.loading {
position: fixed;
top: 60%;
left: 50%;
transform: translate(-50%, -50%);
color: #ff69b4;
font-family: â€˜Playfair Displayâ€™, serif;
font-size: clamp(1rem, 3vw, 1.5rem);
z-index: 10;
opacity: 1;
transition: opacity 0.5s ease;
}

.loading.hidden {
opacity: 0;
pointer-events: none;
}

.loading::after {
content: â€˜â€™;
display: inline-block;
width: 20px;
height: 20px;
border: 2px solid #ff69b4;
border-radius: 50%;
border-top-color: transparent;
animation: spin 1s linear infinite;
margin-left: 10px;
vertical-align: middle;
}

@keyframes spin {
to { transform: rotate(360deg); }
}

.instruction {
position: fixed;
bottom: 30px;
left: 50%;
transform: translateX(-50%);
color: rgba(255,105,180,0.8);
font-family: â€˜Playfair Displayâ€™, serif;
font-size: clamp(0.9rem, 2.5vw, 1.2rem);
z-index: 4;
text-align: center;
animation: pulse 3s ease-in-out infinite;
opacity: 0;
transition: opacity 1s ease;
}

.instruction.visible {
opacity: 1;
}

@keyframes pulse {
0%, 100% { opacity: 0.6; }
50% { opacity: 1; }
}

.error-message {
position: fixed;
top: 70%;
left: 50%;
transform: translate(-50%, -50%);
color: rgba(255,105,180,0.7);
font-family: â€˜Playfair Displayâ€™, serif;
font-size: clamp(0.9rem, 2.5vw, 1.1rem);
text-align: center;
z-index: 5;
opacity: 0;
transition: opacity 0.5s ease;
max-width: 80%;
line-height: 1.5;
}

.error-message.visible {
opacity: 1;
}

/* RIP button and counter styles */
.rip-section {
position: fixed;
bottom: 20px;
left: 20px;
display: flex;
flex-direction: column;
align-items: center;
z-index: 5;
pointer-events: auto;
}

.rip-button {
background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.2));
border: 1.5px solid rgba(255,255,255,0.3);
border-radius: 50%;
width: 45px;
height: 45px;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
transition: all 0.3s ease;
backdrop-filter: blur(10px);
margin-bottom: 6px;
}

.rip-button:hover {
background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.3));
border-color: rgba(255,255,255,0.5);
transform: scale(1.1);
box-shadow: 0 4px 15px rgba(255,255,255,0.2);
}

.rip-button:active {
transform: scale(0.95);
}

.dove-icon {
font-size: 18px;
color: rgba(255,255,255,0.9);
text-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

.rip-counter {
color: rgba(255,255,255,0.8);
font-family: â€˜Playfair Displayâ€™, serif;
font-size: 0.85rem;
text-align: center;
text-shadow: 0 1px 3px rgba(0,0,0,0.5);
line-height: 1.2;
}

/* Button animation when clicked */
@keyframes ripBlessing {
0% { transform: scale(1); }
50% { transform: scale(1.2); }
100% { transform: scale(1); }
}

.rip-button.blessing {
animation: ripBlessing 0.4s ease-out;
}

/* Flying dove animation */
.flying-dove {
position: fixed;
font-size: 20px;
color: rgba(255,255,255,0.9);
pointer-events: none;
z-index: 15;
text-shadow: 0 2px 8px rgba(255,255,255,0.3);
animation: flyToHeaven 3s ease-out forwards;
}

@keyframes flyToHeaven {
0% {
opacity: 1;
transform: translateY(0) translateX(0) scale(1) rotate(0deg);
}
25% {
opacity: 1;
transform: translateY(-25vh) translateX(20px) scale(1.1) rotate(5deg);
}
50% {
opacity: 0.8;
transform: translateY(-50vh) translateX(-10px) scale(1.2) rotate(-3deg);
}
75% {
opacity: 0.4;
transform: translateY(-75vh) translateX(30px) scale(1.3) rotate(8deg);
}
100% {
opacity: 0;
transform: translateY(-100vh) translateX(10px) scale(1.5) rotate(0deg);
}
}

/* Alternative: Glowing orb animation */
.spirit-orb {
position: fixed;
width: 12px;
height: 12px;
background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,255,255,0.8) 30%, rgba(255,255,255,0) 100%);
border-radius: 50%;
pointer-events: none;
z-index: 15;
box-shadow:
0 0 10px rgba(255,255,255,0.8),
0 0 20px rgba(255,255,255,0.6),
0 0 30px rgba(255,255,255,0.4);
animation: spiritRise 4s ease-out forwards;
}

@keyframes spiritRise {
0% {
opacity: 1;
transform: translateY(0) scale(0.5);
}
10% {
opacity: 1;
transform: translateY(-10vh) scale(1);
}
50% {
opacity: 0.8;
transform: translateY(-50vh) scale(1.2);
}
80% {
opacity: 0.3;
transform: translateY(-80vh) scale(1.5);
}
100% {
opacity: 0;
transform: translateY(-100vh) scale(2);
}
}

/* Mobile responsiveness */
@media (max-width: 480px) {
.rip-section {
bottom: 15px;
left: 15px;
}

.rip-button {
width: 40px;
height: 40px;
}

.dove-icon {
font-size: 16px;
}

.rip-counter {
font-size: 0.8rem;
}
}
</style>

</head>
<body>
<h1>
  In Memory Of<br>
  <span style="white-space: nowrap;">Aaron Anthony Ebanks</span>
</h1>

<div class="loading" id="loadingIndicator">
  Loading cherished memories...
</div>

<div class="instruction" id="instructionText">
  Move your cursor or touch the screen to reveal photos
</div>

<div class="error-message" id="errorMessage">
  Some photos couldn't be loaded, but the memories live on in our hearts
</div>

<!-- RIP section -->

<div class="rip-section">
  <button class="rip-button" id="ripButton" title="Send a prayer">
    <span class="dove-icon">ðŸ•Š</span>
  </button>
  <div class="rip-counter">
    <div>Rest In Peace</div>
    <div id="ripCount">0</div>
  </div>
</div>

<canvas id="revealCanvas"></canvas>

<div class="glow"></div>
<script>
const glow = document.querySelector('.glow');
const canvas = document.getElementById('revealCanvas');
const ctx = canvas.getContext('2d');
const loadingIndicator = document.getElementById('loadingIndicator');
const instructionText = document.getElementById('instructionText');
const errorMessage = document.getElementById('errorMessage');
const ripButton = document.getElementById('ripButton');
const ripCountElement = document.getElementById('ripCount');

let radius = 120;
let animationId = null;

// RIP counter - starts at 0
let ripCount = 0;

// Expandable image collection - add more images for larger screens
const imageSources = [
  'img1.jpg','img2.jpg','img3.jpg','img4.jpg','img5.jpg',
  'img6.jpg','img7.jpg','img8.jpg','img9.jpg','img10.jpg',
  'img11.jpg','img12.jpg','img13.jpg','img14.jpg','img15.jpg',
  'img16.jpg','img17.jpg','img18.jpg','img19.jpg','img20.jpg',
  'img21.jpg','img22.jpg','img23.jpg','img24.jpg','img25.jpg',
  'img26.jpg','img27.jpg','img28.jpg','img29.jpg','img30.jpg',
  'img31.jpg','img32.jpg','img33.jpg','img34.jpg','img35.jpg',
  'img36.jpg','img37.jpg','img38.jpg','img39.jpg','img40.jpg',
  'img41.jpg','img42.jpg','img43.jpg','img44.jpg','img45.jpg',
  'img46.jpg','img47.jpg','img48.jpg','img49.jpg','img50.jpg'
];

const images = [];
let loadedCount = 0;
let errorCount = 0;
let bufferCanvas = document.createElement('canvas');
let bufferCtx = bufferCanvas.getContext('2d');

let w, h, cols, rows, totalImages;
let fadeMask;
let isInitialized = false;

// Create a placeholder image for failed loads
function createPlaceholder(width, height) {
  const placeholderCanvas = document.createElement('canvas');
  placeholderCanvas.width = width;
  placeholderCanvas.height = height;
  const pCtx = placeholderCanvas.getContext('2d');
  
  // Create a subtle gradient background
  const grad = pCtx.createLinearGradient(0, 0, width, height);
  grad.addColorStop(0, 'rgba(255,105,180,0.1)');
  grad.addColorStop(1, 'rgba(255,105,180,0.05)');
  pCtx.fillStyle = grad;
  pCtx.fillRect(0, 0, width, height);
  
  // Add a heart symbol
  pCtx.fillStyle = 'rgba(255,105,180,0.3)';
  pCtx.font = `${Math.min(width, height) * 0.3}px serif`;
  pCtx.textAlign = 'center';
  pCtx.textBaseline = 'middle';
  pCtx.fillText('â™¥', width/2, height/2);
  
  return placeholderCanvas;
}

// Calculate optimal grid size based on screen dimensions
function calculateGridSize() {
  const screenWidth = window.innerWidth;
  const screenHeight = window.innerHeight;
  
  // Define target cell size ranges for different screen types
  let targetCellSize;
  
  if (screenWidth <= 480) {
    // Phone: smaller cells, fewer images
    targetCellSize = Math.min(screenWidth, screenHeight) * 0.2;
    cols = Math.floor((screenWidth * 0.9) / targetCellSize);
    rows = Math.floor((screenHeight * 0.7) / targetCellSize);
  } else if (screenWidth <= 768) {
    // Tablet: medium cells, more images
    targetCellSize = Math.min(screenWidth, screenHeight) * 0.15;
    cols = Math.floor((screenWidth * 0.9) / targetCellSize);
    rows = Math.floor((screenHeight * 0.8) / targetCellSize);
  } else if (screenWidth <= 1200) {
    // Small laptop/desktop
    targetCellSize = Math.min(screenWidth, screenHeight) * 0.12;
    cols = Math.floor((screenWidth * 0.9) / targetCellSize);
    rows = Math.floor((screenHeight * 0.85) / targetCellSize);
  } else {
    // Large desktop: smallest cells, maximum images
    targetCellSize = Math.min(screenWidth, screenHeight) * 0.1;
    cols = Math.floor((screenWidth * 0.9) / targetCellSize);
    rows = Math.floor((screenHeight * 0.9) / targetCellSize);
  }
  
  // Ensure minimum grid size
  cols = Math.max(cols, 3);
  rows = Math.max(rows, 2);
  
  // Cap maximum for performance
  cols = Math.min(cols, 12);
  rows = Math.min(rows, 8);
  
  totalImages = cols * rows;
  
  // Adjust cell size to fill screen optimally
  const maxWidth = window.innerWidth * 0.9;
  const maxHeight = window.innerHeight * 0.9;
  const cellWidth = maxWidth / cols;
  const cellHeight = maxHeight / rows;
  const cellSize = Math.min(cellWidth, cellHeight);
  
  w = cellSize * cols;
  h = cellSize * rows;
  
  return cellSize;
}

// Resize and draw collage onto buffer
function resizeAndDrawCollage() {
  const cellSize = calculateGridSize();
  
  canvas.width = w;
  canvas.height = h;
  bufferCanvas.width = w;
  bufferCanvas.height = h;

  // Draw all images into buffer grid
  bufferCtx.clearRect(0, 0, w, h);
  let i = 0;
  
  for(let r = 0; r < rows; r++){
    for(let c = 0; c < cols; c++){
      const x = c * cellSize;
      const y = r * cellSize;
      
      // Use modulo to cycle through available images if we need more than we have
      const imageIndex = i % imageSources.length;
      
      if(images[imageIndex]) {
        bufferCtx.drawImage(images[imageIndex], x, y, cellSize, cellSize);
      } else {
        // Use placeholder for missing images
        const placeholder = createPlaceholder(cellSize, cellSize);
        bufferCtx.drawImage(placeholder, x, y);
      }
      i++;
      
      // Stop if we've filled all grid positions
      if (i >= totalImages) break;
    }
    if (i >= totalImages) break;
  }
}

function createFadeMask() {
  fadeMask = document.createElement('canvas');
  fadeMask.width = radius * 2;
  fadeMask.height = radius * 2;
  const mctx = fadeMask.getContext('2d');
  const grad = mctx.createRadialGradient(radius, radius, radius*0.6, radius, radius, radius);
  grad.addColorStop(0, 'rgba(0,0,0,1)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  mctx.fillStyle = grad;
  mctx.beginPath();
  mctx.arc(radius, radius, radius, 0, Math.PI*2);
  mctx.fill();
}

function drawMask(x, y) {
  if (!isInitialized) return;
  
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, w, h);
  
  if (x > 0 && y > 0 && x < w && y < h) {
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.drawImage(fadeMask, x - radius, y - radius);
    ctx.restore();
    ctx.globalCompositeOperation = 'destination-over';
    ctx.drawImage(bufferCanvas, 0, 0);
    ctx.globalCompositeOperation = 'source-over';
  }
}

// Throttled position update for better performance
function updatePosition(pageX, pageY) {
  if (animationId) return;
  
  animationId = requestAnimationFrame(() => {
    glow.style.left = `${pageX}px`;
    glow.style.top = `${pageY}px`;
    
    const rect = canvas.getBoundingClientRect();
    const localX = pageX - rect.left;
    const localY = pageY - rect.top;
    drawMask(localX, localY);
    
    animationId = null;
  });
}

function hideLoadingAndShowInstructions() {
  loadingIndicator.classList.add('hidden');
  
  // Show instructions after a brief delay
  setTimeout(() => {
    instructionText.classList.add('visible');
  }, 500);
  
  // Show error message if there were failed loads
  if (errorCount > 0) {
    setTimeout(() => {
      errorMessage.classList.add('visible');
    }, 1000);
  }
}

function initializeCanvas() {
  resizeAndDrawCollage();
  createFadeMask();
  drawMask(-9999, -9999);
  isInitialized = true;
  hideLoadingAndShowInstructions();
}

// RIP counter function
function updateRipCount() {
  ripCountElement.textContent = ripCount.toLocaleString();
}

// Create flying dove animation
function createFlyingDove(startX, startY) {
  const dove = document.createElement('div');
  dove.className = 'flying-dove';
  dove.textContent = 'ðŸ•Š';
  dove.style.left = startX + 'px';
  dove.style.top = startY + 'px';
  document.body.appendChild(dove);
  
  // Remove dove after animation completes
  setTimeout(() => {
    if (dove.parentNode) {
      dove.parentNode.removeChild(dove);
    }
  }, 3000);
}

// Alternative: Create glowing spirit orb animation
function createSpiritOrb(startX, startY) {
  const orb = document.createElement('div');
  orb.className = 'spirit-orb';
  orb.style.left = startX + 'px';
  orb.style.top = startY + 'px';
  document.body.appendChild(orb);
  
  // Remove orb after animation completes
  setTimeout(() => {
    if (orb.parentNode) {
      orb.parentNode.removeChild(orb);
    }
  }, 4000);
}

// RIP button functionality
ripButton.addEventListener('click', (e) => {
  // Add blessing animation to button
  ripButton.classList.add('blessing');
  
  // Increment RIP counter
  ripCount++;
  updateRipCount();
  
  // Get button position for animation start point
  const rect = ripButton.getBoundingClientRect();
  const startX = rect.left + rect.width / 2;
  const startY = rect.top + rect.height / 2;
  
  // Create flying dove (you can switch to createSpiritOrb for orb effect)
  createFlyingDove(startX, startY);
  
  // Remove animation class after animation completes
  setTimeout(() => {
    ripButton.classList.remove('blessing');
  }, 400);
  
  // Prevent event bubbling
  e.stopPropagation();
});

// Load images with smart loading - only load what we might need
function loadImagesForScreen() {
  // Calculate how many images we might need
  calculateGridSize();
  const imagesToLoad = Math.min(imageSources.length, Math.max(totalImages, 20)); // Always load at least 20
  
  // Load images up to what we need
  for (let i = 0; i < imagesToLoad; i++) {
    const img = new Image();
    
    img.onload = () => {
      images[i] = img;
      loadedCount++;
      
      if (loadedCount + errorCount >= imagesToLoad) {
        initializeCanvas();
      }
    };
    
    img.onerror = () => {
      console.warn(`Failed to load image: ${imageSources[i]}`);
      errorCount++;
      
      if (loadedCount + errorCount >= imagesToLoad) {
        initializeCanvas();
      }
    };
    
    // Set source after event handlers to avoid race conditions
    img.src = imageSources[i];
  }
}

// Touch events with improved handling
document.addEventListener('touchstart', e => {
  e.preventDefault();
  if (e.touches.length > 0) {
    glow.style.opacity = '1';
    updatePosition(e.touches[0].clientX, e.touches[0].clientY);
  }
}, { passive: false });

document.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length > 0) {
    updatePosition(e.touches[0].clientX, e.touches[0].clientY);
  }
}, { passive: false });

document.addEventListener('touchend', e => {
  glow.style.opacity = '0';
  drawMask(-9999, -9999);
}, { passive: true });

// Mouse events
document.addEventListener('mousemove', e => {
  glow.style.opacity = '1';
  updatePosition(e.clientX, e.clientY);
});

document.addEventListener('mouseleave', () => {
  glow.style.opacity = '0';
  drawMask(-9999, -9999);
});

// Handle window resize with debouncing
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    if (isInitialized) {
      resizeAndDrawCollage();
      createFadeMask();
      drawMask(-9999, -9999);
    }
  }, 250);
});

// Initialize RIP counter and start loading
updateRipCount();
loadImagesForScreen();

// Fallback initialization in case no images load
setTimeout(() => {
  if (!isInitialized) {
    console.warn('Initializing with placeholder images due to loading timeout');
    initializeCanvas();
  }
}, 10000); // 10 second timeout
</script>

</body>
</html>
</body>
</html>